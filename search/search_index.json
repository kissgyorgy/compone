{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p>Compone is a Python component framework which makes it possible to generate HTML, XML, RSS and other markup formats using type-safe  Python objects with a very simple API.</p> <p><code>compone.Component</code>s are fully-reusable Python classes in ANY Python web framework or project out-of-the-box without extra code needed.</p> <p>It's a modern alternative to template engines like Jinja2 or Django templates for generating strings.</p>"},{"location":"#hello-world","title":"Hello World","text":"<pre><code>from compone import Component, html\n\n@Component\ndef Hello(name: str, children):\n    return html.Div[\n        html.H1[f\"Hello {name}!\"],\n        children,\n    ]\n\nprint(Hello(\"World\")[\"My Child\"])\n# &lt;div&gt;&lt;h1&gt;Hello World!&lt;/h1&gt;My Child&lt;/div&gt;\n</code></pre> <p>This is a very silly example, but for more examples and features, check out the Tutorial.</p>"},{"location":"#installation","title":"Installation","text":"<p>You can simply install the <code>compone</code> package from PyPI:</p> <pre><code>$ pip install compone\n</code></pre> <p>The only dependency is markupsafe for escaping HTML.</p>"},{"location":"#motivation","title":"Motivation","text":"<p> The main reason why I created Compone is when I tried React.JS, it felt really-really productive with the component-based architecture. When I worked with Python web frameworks, I really missed that huge boost in productivity.</p> <p> I always disliked template engines, mostly because working with them was very cumbersome. When you wanted to create a reusable piece, you had to create yet-another-template, in yet-another-file in a specific directory, include it in another template, and so on.</p> <p> I never seen implemented truly reusable templates, probably because they are not very convenient to do that and it's not the main goal of template engines. It's also hard to create a reusable piece of HTML in a template engine.</p> <p> Another reason was that it always felt that presentation was far from my code, I always had to juggle between different files, which was very annoying and cumbersome.</p> <p> Also implicit function calling is a big mistake in template engines, because it leads to side-effects, N+1 query problems and hard-to-debug code.</p> <p> Also different template engines are not really re-usable between different web frameworks. It took years for Django to implement Jinja2 support, and it will still never be as powerful as Django templates.</p> <p> The recent trend of new \"modern\" Python web frameworks (like ReactPy, Streamlit, Reflex, Ludic and co.) to invent their own component system is fragmenting the Python web ecosystem, because components written for one are not reusable for others.</p> <p> In compone land, everything is just regular Python, no magic, no implicit function calling, you can organize your code as you like and every <code>compone.Component</code> works accross  every Python web framework already.</p>"},{"location":"#my-vision","title":"My Vision","text":"<p>My vision for Compone is to build a rich ecosystem of Component Libraries for popular frameworks based on a very simple API on Compone Core, which can be reused in any Python projects.</p> <p>The goal is to create simple tools and APIs, which the community can quickly and easily build custom Component frameworks and libraries for any design system and share them with the whole Python community, not just specific frameworks.</p>"},{"location":"#license","title":"License","text":"<p>Compone is MIT licensed and all of the projects related to compone are also MIT licensed.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#040","title":"0.4.0","text":"<p>This is the biggest release yet, very close to the final API, but I want people to try it out first before I release 1.0.0. I'm using compone in production for years now.</p> <ul> <li>Simplify APIs, remove <code>__call__</code></li> <li>Disallow using Python keywords as arguments, now only the underscore versions   are allowed (e.g. <code>class_</code> instead of <code>class</code>).</li> <li><code>escape</code> now escapes iterables too by concatenating the escaped elements</li> <li>Allow function components with <code>@lru_cache</code></li> </ul>"},{"location":"changelog/#030","title":"0.3.0","text":"<p>All HTML elements are Components now instead of safe objects. Even <code>html.Br</code> can have attributes.</p>"},{"location":"changelog/#021","title":"0.2.1","text":"<p>Compatibility with non-str objects like Django <code>gettext_lazy</code>.</p>"},{"location":"changelog/#020","title":"0.2.0","text":"<ul> <li>HTMX helpers.</li> <li><code>classes</code> HTML attribute helper.</li> <li>Preline UI Component Framework sketch.</li> </ul>"},{"location":"changelog/#010","title":"0.1.0","text":"<p>After lots of experimentation for a nice API, this is the first version  where I was satisfied with the API.</p> <p>All the HTML elements were implemented in this version and I made it work with Flask and Django.</p> <p>Custom autoescaping was implemented in this version too, but later I switched to MarkupSafe.</p> <p>Tried to implement React-like \"hooks\", but it made no sense in Python world, so I abandoned that idea.</p> <p>Started compone Stories, which is already useful.</p> <p>I already used this version in production for months, later versions only refined the API and made convenience features.</p>"},{"location":"ecosystem/","title":"Ecosystem","text":"<p>Compone Core is the library used by Component projects. This is the <code>compone</code> package what you install and import in your projects to create your custom Components.</p> <p>Compone Stories is a Storybook-like tool for Component projects, which can render Components in the browser interactively.</p> <p>Framework libraries are Component libraries for well-known design systems and component frameworks like Bootstrap, Materialize, Preline UI, daisyUI, etc. These compone libraries contain <code>compone Component</code>s that are styled according to the framework's design system.</p> <p>Compone CLI is a CLI tool for faciliating the development of Components, starting Compone Stories, generating static sites and more.</p> <p>Compone SSG is a static site generator that can render Components to fully static HTML websites.</p>"},{"location":"tutorial/","title":"Tutorial","text":"<p>By doing this tutorial you can learn the full <code>compone</code> API very quickly, because there are only a couple of concepts and methods you need to know about to effectively use <code>compone</code>.</p>"},{"location":"tutorial/#hello-world","title":"Hello World","text":"<pre><code>from compone import Component, html\n\n@Component\ndef Hello(name: str):\n    return html.Div[\n        html.H1[f\"Hello {name}!\"],\n    ]\n\ncontent = str(Hello(\"World\"))\nprint(content)\n# &lt;div&gt;&lt;h1&gt;Hello World!&lt;/h1&gt;&lt;/div&gt;\n</code></pre> <p>What's going on here?</p> <ul> <li>We are defining a new Component with the <code>@Component</code> decorator, with one prop: <code>name</code>.   It converts the function into a Component class under the hood.</li> <li>We use the square brackets syntax (<code>__getitem__</code>) to specify   the children of the <code>Div</code> element.   Same for the <code>H1</code> element with our text.</li> <li>We \"render\" the Component into a string then print it.</li> </ul> <p>functions are converted to classes</p> <p>It's important to know that functions with the <code>@Component</code> decorator are dynamically converted to classes, so you are not calling the function directly, but creating an instance of your <code>Component</code> class and calling it's <code>__str__</code> method when rendering it.</p> <p>Why don't we just use a simple function to return strings? That's a good question! See the next chapters for features that make <code>Component</code>s more powerful than doing that.</p>"},{"location":"tutorial/#composability-with-children","title":"Composability with children","text":"<p>The main feature of compone is the ability to compose <code>Component</code>s with other Components via the children parameter. (The concept is similar to React.js). This way any component can be nested inside another component. There are 2 ways you can pass children to a Component:</p>"},{"location":"tutorial/#bracket-syntax","title":"Bracket syntax","text":"<p>Here is an example of nesting two of your custom Components: <pre><code>from compone import Component\n\n@Component\ndef Parent(children = \"\"):\n    return f\"\"\"\n        --- Start of Parent ---\n        {children}\n        --- End of Parent ---\n    \"\"\"\n\n@Component\ndef Children(children = \"\"):\n    return f\"\"\"\n        --- Start of Children ---\n        {children}\n        --- End of Children ---\n    \"\"\"\n\nprint(\n    Parent[\n        Children[\"Hello World\"]\n    ]\n)\n</code></pre></p> <p>This will print: <pre><code>        --- Start of Parent ---\n\n        --- Start of Children ---\n        Hello World\n        --- End of Children ---\n\n        --- End of Parent ---\n</code></pre></p> <p>Whitespace</p> <p>Note the whitespace before the lines, which is because of spaces and newlines in the multiline strings.</p> <p>Ther rendering is lazy, all the children will be rendered only at the time parent is rendered.</p> <p>You can return a list from a Component, and it's elements will be concatenated:</p> <pre><code>from compone import Component, html\n\n@Component\ndef ListParent(children = \"\"):\n    return [\n        \"--- Start of Parent ---\",\n        children,\n        \"--- End of Parent ---\",\n    ]\n\n@Component\ndef ListChildren(children = \"\"):\n    return [\n        \"--- Start of Children ---\",\n        children,\n        \"--- End of Children ---\"\n    ]\n\nprint(\n    ListParent[\n        ListChildren[\"Hello World\"]\n    ]\n)\n</code></pre> <p>This doesn't print whitespaces like the previous example, because the list elements are concatenated directly:</p> <pre><code>--- Start of Parent ------ Start of Children ---Hello World--- End of Children ------ End of Parent ---\n</code></pre>"},{"location":"tutorial/#context-manager-syntax","title":"Context manager syntax","text":"<p>When you have more complex Components with a lot more children (like in HTML usually),  you can use the context manager syntax.</p> <pre><code>from compone import Component\n\n@Component\ndef Section(*, title: str, children):\n    return html.Div[\n        html.H1[title],\n        children,\n    ]\n\n@Component\ndef Article(title: str, children):\n    return html.Article[\n        html.H2[title],\n        children,\n    ]\n\nwith Section(title=\"Section title\") as main:\n    with Article(title=\"Article title\") as article: \n        article += html.P[\"World\"]\n\nprint(main)\n</code></pre> <p>Output (no spaces): <pre><code>&lt;div&gt;\n  &lt;h1&gt;Section title&lt;/h1&gt;\n  &lt;article&gt;\n    &lt;h2&gt;Article title&lt;/h2&gt;\n    &lt;p&gt;World&lt;/p&gt;\n  &lt;/article&gt;\n&lt;/div&gt;\n</code></pre></p> <p>As you can see, you can mix and match the two syntaxes, any way you like.</p> <p>My suggestion is to use the bracket syntax for simpler, shorter Components, and the context manager syntax for more complex Components, especially when you want to have custom code in the middle of a Component.</p>"},{"location":"tutorial/#html-components","title":"HTML Components","text":"<p>All HTML tags are available as Components in the <code>html</code> module. Here is a full HTML page with separate Components for sections:</p> <pre><code>import datetime as dt\nfrom compone import Component, html\n\n@Component\ndef Page(title: str, children):\n    return html.Html[\n        html.Head[\n            html.Title[title],\n            html.Meta(name=\"author\", content=\"Gy\u00f6rgy Kiss\"),\n        ],\n        html.Body[children],\n    ]\n\n@Component\ndef Header():\n    return html.Header[html.H1[\"Header\"],]\n\n@Component\ndef Content(children):\n    return html.Article[children]\n\n@Component\ndef Footer():\n    return html.Footer[\n        html.P[\n            \"Footer\",\n            html.Br(),\n            \"Copyright \u00a9\",\n            dt.datetime.now().year,\n        ],\n    ]\n\npage = Page(title=\"My awesome website\")[\n    Header(),\n    Content[\"Main content\"],\n    Footer(),\n]\n\nprint(page)\n</code></pre> <p>This will print (without indentation):</p> <pre><code>&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;My awesome website&lt;/title&gt;\n    &lt;meta name=\"author\" content=\"Gy\u00f6rgy Kiss\" /&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;header&gt;&lt;h1&gt;Header&lt;/h1&gt;&lt;/header&gt;\n    &lt;article&gt;Main content&lt;/article&gt;\n    &lt;footer&gt;\n      &lt;p&gt;Footer&lt;br /&gt;Copyright \u00a92024&lt;/p&gt;\n    &lt;/footer&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"tutorial/#html-attributes","title":"HTML attributes","text":"<p>Any parameter you pass to an HTML Component will be rendered as HTML attribute, with underscores converted to dashes: <pre><code>print(html.Div(id=\"my-id\", some_attribute=\"value\", data_value=\"data\"))\n# &lt;div id=\"my-id\" some-attribute=\"value\" data-value=\"data\"&gt;&lt;/div&gt;\n</code></pre></p> <p>For Python keywords, append an underscore to the attribute name: <pre><code>print(html.Div(class_=\"my-class\"))\n# &lt;div class=\"my-class\"&gt;&lt;/div&gt;\n\nprint(html.Label(for_=\"my-for\"))\n# &lt;label for=\"my-for\"&gt;&lt;/label&gt;\n</code></pre></p> <p>Boolean type attributes will be rendered only when <code>True</code>: <pre><code>print(html.Button(disabled=True))\n# &lt;button disabled&gt;&lt;/button&gt;\n\nprint(html.Label(disabled=False))\n# &lt;button&gt;&lt;/button&gt;\n</code></pre></p> <p>List attribute types will be joined with spaces: <pre><code>print(html.Div(class_=[\"class1\", \"class2\"]))\n# &lt;div class=\"class1 class2\"&gt;&lt;/div&gt;\n</code></pre></p>"},{"location":"tutorial/#html-autoescape","title":"HTML autoescape","text":"<p>Every HTML attribute and children will be automatically escaped by default. You can opt-out with marking the string with the <code>safe</code> class (which uses MarkupSafe under the hood for now.). Every Component is safe by default.</p> <pre><code>from compone import html, safe\n\nevil_user_input = \"&lt;script&gt;alert('Hello!')&lt;/script&gt;\"\nsafe_div = html.Div[evil_user_input]\nprint(safe_div)\n# &lt;div&gt;&amp;lt;script&amp;gt;alert(&amp;#39;Hello!&amp;#39;)&amp;lt;/script&amp;gt;&lt;/div&gt;\n</code></pre> <p>Danger</p> <p>Be careful when using <code>safe</code>, always think about every single case whether it will contain user input or not, don't just blindly apply it when you encounter an escaped content which should be rendered as html.</p> <p>For example, you can't just mark <code>safe</code> a dynamically rendered JavaScript which contains user input, because it can lead to XSS attacks.</p> <p>If you pass a list or <code>*args</code> as HTML Component children, <code>str</code> will be autoescaped, <code>safe</code> objects will be rendered as is:</p> <pre><code>from compone import html, safe\n\nevil_username = '&lt;script&gt;alert(\"Hello!\")&lt;/script&gt;'\nlook_ma_no_xss = html.Div[\n    safe(\"&lt;script&gt;console.log('Valid script')&lt;/script&gt;\"),\n    evil_username,\n]\nprint(look_ma_no_xss)\n# &lt;div&gt;&lt;script&gt;console.log('Valid script')&lt;/script&gt;&amp;lt;script&amp;gt;alert(&amp;#34;Hello!&amp;#34;)&amp;lt;/script&amp;gt;&lt;/div&gt;\n</code></pre> <p>This still doesn't protect against XSS</p> <p>This is still susceptible to XSS attacks, you have to escape user input differently when injecting it to JavaScript context. See OWASP XSS prevention cheat sheet to defend against different kind of attacks.</p>"},{"location":"tutorial/#html-helpers","title":"HTML helpers","text":"<p>There are some helpers to make it less cumbersome when working with HTML.</p> <p>You can manipulate the html <code>class</code> attribute easier with the <code>html.classes</code> helper. It is inspired by the <code>classnames</code> JavaScript library.</p> <p>Dynamically applying classes to HTML <code>class</code> property:</p> <pre><code>my_dynamic_classes = html.classes({\"red\": False, \"green\": True})\nprint(html.Div(class_=my_dynamic_classes))\n# &lt;div class=\"green\"&gt;&lt;/div&gt;\n</code></pre> <p>Concatenating list of classes with strings:</p> <pre><code>my_classes = html.classes(\"red\", \"green\", [\"blue\", \"yellow\"], \"brown black\")\nprint(html.Div(class_=my_classes))\n# &lt;div class=\"red green blue yellow brown black\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"tutorial/#component-introspection","title":"Component introspection","text":"<p>If for some reason you need to inspect a Component class, you can use the <code>.props</code> property for all parameters of the instance:</p> <pre><code>@Component\ndef MyComponent(a=1, b=2):\n    return str(a*b)\n\nmy_component = MyComponent()\nprint(my_component.props)\n# {'a': 1, 'b': 2}\n</code></pre> <p>You can access the children of a Component instance with the <code>.children</code> property: <pre><code>@Component\ndef MyComponent(a=1, b=2, children=None):\n    return html.Div[str(a*b), children]\n\nmy_component = MyComponent[\"My Content\", html.P[\"New paragraph\"]]\nprint(my_component.children)\n# ('My Content', &lt;P()&gt;)\n</code></pre></p>"},{"location":"tutorial/#class-components","title":"Class components","text":"<p>In rare cases when you have a complex logic and want to sticky it to one class, you can use the <code>Component</code> decorator on classes too. The class only need to have a <code>.render()</code> method.</p> <pre><code>@Component\nclass MyComponent:\n    def __init__(self, a=1, b=2):\n        self._a = a\n        self._b = b\n\n    def render(self, children):\n        return html.Div[str(self._a * self._b), \" \", children]\n\nmy_component = MyComponent(2, 3)[\"eggs\"]\nprint(my_component)\n# &lt;div&gt;6 eggs&lt;/div&gt;\n</code></pre> <p>Works the same as function components</p> <p>This works the same way as function Components, the decorator  converts your class to a Component class and calls your <code>.render()</code>  method when the Component <code>__str__</code> method is called.</p>"},{"location":"web_frameworks/","title":"Web frameworks","text":"<p>compone is framework agnostic, you can use it in any Python web framework. Here are a couple of examples how.</p>"},{"location":"web_frameworks/#django","title":"Django","text":""},{"location":"web_frameworks/#flask","title":"Flask","text":""},{"location":"web_frameworks/#fastapi","title":"FastAPI","text":""}]}